---
title: 关于“小刚的架构思考：什么是架构”的思考
tags: [杂文,架构]
categories: [杂文]
date: 2016-12-30 14:55:50
---

原文
---
[小刚原文](http://keeganlee.me/post/architecture/20160425)
转载自[Keegan小刚](http://keeganlee.me)

最近在思考架构方面一些最基本的问题，比如什么是架构？如何评价一个架构的好坏？是否有一些通用的基本原则指引架构设计？在面向对象设计方面，有单一职责、里氏替换、依赖倒置、接口隔离、迪米特、开闭原则等等基本原则；那么，在架构设计方面是否也有类似的基本原则呢？本文就先聊聊第一个问题。

#########################

**单一职责** 单一职责原则(SRP: Single responsibility principle)又称单一功能原则，面向对象五个基本原则(SOLID)之一。它规定一个类应该只有一个发生变化的原因。每一个职责都是变化的曲线，如果一个类有一个以上的职责，这些职责就会耦合在一起，从而导致脆弱的设计。当一个职责发生变化时，可能会影响其他的职责。另外，多个职责耦合在一起，会影响复用性。
**开闭原则** 开放封闭原则(Open-Closed principle),核心思想是，软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭。开闭原则主要体现在两个方面：
<!--more-->
1. 对扩展开放，意味着有新需求或变化时，可以对现有代码进行扩展，以适应新的情况。
2. 对修改封闭，意味着类一旦设计完成，就可以独立完成工作，而不需要并且避免对其进行修改。
实现开闭原则的核心是对抽象编程，而不对具体编程，因为抽象相对稳定。让类依赖于固定的抽象，所以修改就是封闭的；而通过面向对象的继承和多态机制，又可以实现对抽象类的继承，通过覆盖其方法来改变固有行为，实现新的拓展方法，所以就是开放的。
**Liskov替换原则** 里氏替换(Liskov-Substituion Principle),核心思想是，子类必须能够替换其基类。这一思想体现对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。在父类和子类的具体行为中，必须严格把握继承层次中的关系和特征，将基类替换成子类，程序的行为不会发生任何变化。同时，这一约束反过来则是不成立的，子类可以替换基类，但是基类不一定能替换子类。
**接口隔离原则** 接口隔离(Interface-Segregation Principle) ,使用多个小的专门的接口，而不要使用一个大的总结口。具体而言，接口隔离原则体现在:接口应该是内聚的，应该避免“胖”接口。一个类对另外一个类的依赖应该建立在最小的接口上，不要强迫依赖不用的方法，这是一种接口污染。
接口有效地将细节和抽象隔离，体现了对抽象编程的一切好处，接口隔离强调接口的单一性。而胖借口存在明显的弊端，会导致实现的类型必须完全实现接口的所有方法、属性等；而某些时候，实现类型并非需要所有的接口定义，在设计上这是浪费，而且在实施上这会带来潜在的问题，对胖接口的修改将导致一连串的客户端程序需要修改，有时候这是一种灾难。在这种情况下，将胖接口分解为多个特点的定制化方法，使得客户端仅仅依赖它们的实际调用的方法，从而解除了客户端不会依赖于它们不用的方法。
分离的主要手段有：
1. 委托分离，通过增加一个新的类型来委托客户的请求，隔离客户和接口的直接依赖，但是会增加系统的开销。
2. 多重继承分离，通过接口多继承来实现客户的需求，这种方式是较好的。
**依赖倒置** 依赖倒置原则(Dependecy-Inversion Principle),依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。
我们知道，依赖一定会存在于类与类，模块与模块之间。当两个模块之间存在紧密的耦合关系时，最好的方法就是分离接口和实现：在依赖之间定义一个抽象接口使得高层模块调用接口，而底层模块实现接口的定义，以此来有效控制耦合关系，达到依赖于抽象的设计目标。
抽象的稳定性决定了系统的稳定性，因为抽象是不变的，依赖于抽象是面向对象设计的精髓，也是依赖倒置原则的核心。
依赖于抽象是一个通用的原则，而某些时候依赖于细节则是在所难免的，必须权衡在抽象和具体之间的取舍，方法不是一成不变的。依赖于抽象，就是对接口编程，不要对实现编程。
**迪米特** 迪米特法则(Law of Demeter)又叫最小知道原则(Least Knowledge Principle简写LKP),就是说一个对象应当对其他对象有尽可能少的了解，不和陌生人说话。有以下几种解释：
* 一个软件实体应当尽可能少的与其他实体发生相互作用。每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。
* 迪米特法则的初衷在于降低类之间的耦合。由于每个类尽量减少对其他类的依赖，因此，很容易使得系统的功能模块功能独立，相互之间不存在依赖关系。
* 迪米特法则不希望类之间建立直接的联系。如果真的有需要建立联系，也希望通过它的友元类来转达。因此，应用迪米特法则有可能造成的一个后果就是：系统中存在大量的中介类，这些类之所以存在完全是为了传递类之间的相互调用关系——这在一定程度上增加了系统的复杂度。

#########################
#### 什么是架构

关于什么是架构，业界从来没有一个统一的定义。Martin Fowler在《企业应用架构模式》中也没有对其给出定义，只是提到能够统一的内容有两点：
  1. 最高层次的系统分解；
  2. 系统中不易改变的决定。
《软件架构设计》一书则将架构定义总结为组成派和决策派：
  * 组成派：架构=组件+交互：软件系统的架构将系统描述为计算组件及组件之间的交互。
  * 决策派：架构=重要决策集：软件架构是在一些重要方面所作出的决策的集合。

而架构的概念最初来源于建筑，因此，我想从建筑的角度去思考这个问题。Wikipedia中，对架构，即 Architecture 的定义如下：
>Architecture is both the process and the product of planning, designing, and constructing buildings and other physical structures.

简单翻译就是：架构是规划、设计和构建建筑物或其他物理构筑物的过程和结果。

从上面的定义中可知，首先，架构的最终目标是为了产出建筑物或其他物理构筑物，构筑物可以只是一套房子，也可以是一栋楼盘，抑或是一个小区、商业区，甚至是一个城市。构筑物越大，其架构必然也越复杂。

其次，产出建筑物之前需要经过三个阶段：规划(planning)、设计(designing)和构建(constructing)。这三个阶段其实也是架构的核心了。比如，开发商要建一个住宅小区，首先肯定要对该小区有一个整体的规划吧：小区的建设选址、建设的规模、建设的内容、投资估算、建设周期等等。接着，就要对小区的各方面进行设计了，最高层次的应该是小区的总体布局设计，拆分开的话就是各楼盘的设计、绿化的设计、各种配套设施的设计等等，再细化下去就是各种户型的设计、楼盘内和小区内各种走道的设计等等。最后，构建阶段也就是施工阶段了，是将之前所有的想法转为实际的建筑物的阶段。

最后，架构包含了以上的过程和结果。也就是说，对小区总体规划的过程是架构，规划的结果方案也是架构，小区总体布局的设计、楼盘的设计、户型的设计等等的每个过程也都是架构，每个过程产出的设计方案也是架构，构建阶段的施工图也是架构，可以说，产出建筑物期间的每个过程和结果都是架构。

那么，如果将建筑物换成了软件，那就变成对软件架构的定义了：软件架构是规划、设计和构建软件的过程和结果。

相应地，软件架构的最终目标就是为了产出软件，可以是一个App，也可以是一个平台，如SaaS、PaaS、BaaS等等，甚至还可以是智慧城市这样庞大的生态系统，地球人都知道，越庞大复杂的系统，架构越难。规划阶段更多考虑的是软件的需求，包括业务上的功能性需求和技术上的非功能性需求，如可靠性、可扩展性、可维护性等；此阶段的架构一般为系统架构。设计阶段的工作更多的就是拆分细化，以满足各种需求；此阶段的架构一般为逻辑架构。构建阶段主要就是对软件的实现和部署了；此阶段的架构一般为物理架构。

#### 写在最后
其实，对架构的每种定义都没有错，就像《软件架构设计》一书也说过的，只是每个人所看的角度不同而已。从上面的定义中也可知，架构涵盖了软件研发的方方面面，很难有人能够全部都懂，大部分架构师懂得的只是其中的某些方面。一栋高楼大厦也不是一个人完成的。

思考完什么是架构之后，那接下来，就要思考架构怎么做了？这个问题留待后文继续思考。
